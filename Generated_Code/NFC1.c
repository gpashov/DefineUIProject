/* ###################################################################
**     This component module is generated by Processor Expert. Do not modify it.
**     Filename    : NFC1.c
**     Project     : QPExMainDeffine_V7790
**     Processor   : MK70FN1M0VMJ15
**     Component   : NFC_LDD
**     Version     : Component 01.008, Driver 01.04, CPU db: 3.00.000
**     Compiler    : GNU C Compiler
**     Date/Time   : 2021-04-07, 14:48, # CodeGen: 0
**     Abstract    :
**          This embedded component implements an access to an on-chip flash memory.
**          Using this component the flash memory could be written to, erased,
**          read from. Some other services would be provided, if they are supported
**          by hardware, e.g. changes of the flash memory protection state.
**     Settings    :
**          Component name                                 : NFC1
**          Device                                         : NFC
**          Clock settings                                 : 
**            Clock frequency/period                       : 9.375 MHz
**            Fast flash timing                            : Disabled
**          Interrupt service/event                        : Enabled
**            Interrupt                                    : INT_NFC
**            Interrupt priority                           : medium priority
**          Memory device organization                     : 
**            Bus width                                    : 8 bit
**            Target list                                  : 1
**              Target0                                    : 
**                Target description                       : 
**                  Page user data size [Bytes]            : 2048
**                  Page spare area size [Bytes]           : 64
**                  Page count                             : 64
**                  Block count                            : 2048
**                  LUN count                              : 1
**                  Total memory size                      : 2112 Mb (1 LUN(s) * 2048 blocks * 64 pages * (2048 data + 64 spare))
**                  Partial page programs cycles           : 4
**                Target settings                          : 
**                  Target ID                              : S34ML02G100BHI000
**                  Pins                                   : 
**                    CE                                   : 
**                      Pin                                : PTC17/CAN1_TX/UART3_TX/ENET0_1588_TMR1/FBa_CS4_b/FBa_TSIZ0/FBa_BE31_24_BLS7_0_b/NFC_CE0_b
**                      Pin signal                         : 
**                    RB                                   : 
**                      Pin                                : PTC16/CAN1_RX/UART3_RX/ENET0_1588_TMR0/FBa_CS5_b/FBa_TSIZ1/FBa_BE23_16_BLS15_8_b/NFC_RB
**                      Pin signal                         : 
**                  Partial page count                     : 1
**                  Page user data size [Bytes]            : 2048
**                  Page spare area size [Bytes]           : 64
**                  Total page count                       : 131072
**                  Block count                            : 2048
**                  Virtual page count                     : 1
**                  Virtual page user data size            : 2048
**                  Virtual page spare area size [Bytes]   : 64
**                  ECC error correction                   : 32-error (60 ECC bytes)
**                    Read page batch size                 : 4
**          Pins                                           : 
**            ALE                                          : 
**              Pin                                        : PTD9/I2C0_SDA/UART5_TX/FBa_A17/NFC_ALE
**              Pin signal                                 : 
**            CLE                                          : 
**              Pin                                        : PTD8/I2C0_SCL/UART5_RX/FBa_A16/NFC_CLE
**              Pin signal                                 : 
**            RE                                           : 
**              Pin                                        : PTD10/UART5_RTS_b/FBa_A18/NFC_RE
**              Pin signal                                 : 
**            WE                                           : 
**              Pin                                        : ADC1_SE7b/PTC11/LLWU_P11/I2C1_SDA/FTM3_CH7/I2S0_RXD1/FBa_RW_b/NFC_WE
**              Pin signal                                 : 
**            Bus width                                    : 8 bit
**              Data 0                                     : 
**                Pin                                      : ADC0_SE6b/PTD5/SPI0_PCS2/UART0_CTS_b/UART0_COL_b/FTM0_CH5/FBa_AD1/NFC_DATA0/EWM_OUT_b
**                Pin signal                               : 
**              Data 1                                     : 
**                Pin                                      : PTD4/LLWU_P14/SPI0_PCS1/UART0_RTS_b/FTM0_CH4/FBa_AD2/NFC_DATA1/EWM_IN
**                Pin signal                               : 
**              Data 2                                     : 
**                Pin                                      : ADC1_SE6b/PTC10/I2C1_SCL/FTM3_CH6/I2S0_RX_FS/FBa_AD5/NFC_DATA2/I2S1_MCLK
**                Pin signal                               : 
**              Data 3                                     : 
**                Pin                                      : ADC1_SE5b/CMP0_IN3/PTC9/FTM3_CH5/I2S0_RX_BCLK/FBa_AD6/NFC_DATA3/FTM2_FLT0
**                Pin signal                               : 
**              Data 4                                     : 
**                Pin                                      : ADC1_SE4b/CMP0_IN2/PTC8/FTM3_CH4/I2S0_MCLK/FBa_AD7/NFC_DATA4
**                Pin signal                               : 
**              Data 5                                     : 
**                Pin                                      : CMP0_IN1/PTC7/SPI0_SIN/USB_SOF_OUT/I2S0_RX_FS/FBa_AD8/NFC_DATA5
**                Pin signal                               : 
**              Data 6                                     : 
**                Pin                                      : CMP0_IN0/PTC6/LLWU_P10/SPI0_SOUT/PDB0_EXTRG/I2S0_RX_BCLK/FBa_AD9/NFC_DATA6/I2S0_MCLK
**                Pin signal                               : 
**              Data 7                                     : 
**                Pin                                      : PTC5/LLWU_P9/SPI0_SCK/LPTMR0_ALT2/I2S0_RXD0/FBa_AD10/NFC_DATA7/CMP0_OUT/I2S1_TX_FS
**                Pin signal                               : 
**          Initialization                                 : 
**            Enabled in init. code                        : yes
**            Auto initialization                          : no
**            Event mask                                   : 
**              OnCmdError                                 : Enabled
**              OnCmdDone                                  : Enabled
**          CPU clock/configuration selection              : 
**            Clock configuration 0                        : This component enabled
**            Clock configuration 1                        : This component disabled
**            Clock configuration 2                        : This component disabled
**            Clock configuration 3                        : This component disabled
**            Clock configuration 4                        : This component disabled
**            Clock configuration 5                        : This component disabled
**            Clock configuration 6                        : This component disabled
**            Clock configuration 7                        : This component disabled
**     Contents    :
**         Init        - LDD_TDeviceData* NFC1_Init(LDD_TUserData *UserDataPtr);
**         Reset       - LDD_TError NFC1_Reset(LDD_TDeviceData *DeviceDataPtr, LDD_NFC_TTargetID...
**         ReadID      - LDD_TError NFC1_ReadID(LDD_TDeviceData *DeviceDataPtr, LDD_NFC_TTargetID...
**         ReadPages   - LDD_TError NFC1_ReadPages(LDD_TDeviceData *DeviceDataPtr, LDD_NFC_TTargetID...
**         WritePages  - LDD_TError NFC1_WritePages(LDD_TDeviceData *DeviceDataPtr, LDD_NFC_TTargetID...
**         EraseBlocks - LDD_TError NFC1_EraseBlocks(LDD_TDeviceData *DeviceDataPtr, LDD_NFC_TTargetID...
**         ReadRawPage - LDD_TError NFC1_ReadRawPage(LDD_TDeviceData *DeviceDataPtr, LDD_NFC_TTargetID...
**
**     Copyright : 1997 - 2014 Freescale Semiconductor, Inc. 
**     All Rights Reserved.
**     
**     Redistribution and use in source and binary forms, with or without modification,
**     are permitted provided that the following conditions are met:
**     
**     o Redistributions of source code must retain the above copyright notice, this list
**       of conditions and the following disclaimer.
**     
**     o Redistributions in binary form must reproduce the above copyright notice, this
**       list of conditions and the following disclaimer in the documentation and/or
**       other materials provided with the distribution.
**     
**     o Neither the name of Freescale Semiconductor, Inc. nor the names of its
**       contributors may be used to endorse or promote products derived from this
**       software without specific prior written permission.
**     
**     THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
**     ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
**     WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
**     DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
**     ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
**     (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
**     LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
**     ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
**     (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
**     SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
**     
**     http: www.freescale.com
**     mail: support@freescale.com
** ###################################################################*/
/*!
** @file NFC1.c
** @version 01.04
** @brief
**          This embedded component implements an access to an on-chip flash memory.
**          Using this component the flash memory could be written to, erased,
**          read from. Some other services would be provided, if they are supported
**          by hardware, e.g. changes of the flash memory protection state.
*/         
/*!
**  @addtogroup NFC1_module NFC1 module documentation
**  @{
*/         

/* MODULE NFC1. */

#include "Events.h"
#include "NFC1.h"
/* {Default RTOS Adapter} No RTOS includes */
#include "NFC_PDD.h"

#ifdef __cplusplus
extern "C" {
#endif


#define NFC1_SRAM_BUFFER_0_IDX               0x00U

#define S34ML02G100BHI000_VIRTUAL_PAGE_USER_DATA_SIZE          0x00000800U
#define S34ML02G100BHI000_VIRTUAL_PAGE_SPARE_AREA_SIZE         0x00000040U
#define S34ML02G100BHI000_VIRTUAL_PAGE_SIZE                    0x00000840U
#define S34ML02G100BHI000_VIRTUAL_PAGE_COUNT                   0x01U

typedef struct NFC1_TEccStatus_Struct {
  uint8_t                     Rsvd0[4];
  uint8_t                     Status;  /* ECC status */
  uint8_t                     Rsvd1[3];
} NFC1_TEccStatus;

typedef struct LDD_NFC_TCmd_struct {
  LDD_NFC_TeCmd            Cmd;        /* Command code */
  union {
    struct {                           /* Read ID command params */
      uint8_t             *DstPtr;     /* Buffer for data */
      uint32_t             Address;    /* Address */
      uint32_t             Size;       /* Size */
    } ReadID;
    struct {                           /* ReadPages command params */
      uint8_t             *DstPtr;     /* Buffer for data */
      uint32_t             PageNum;    /* Page number */
      uint32_t             PageCount;  /* Page count */
    } ReadPages;
    struct {                           /* WritePages command params */
      uint8_t             *SrcPtr;     /* Buffer with data */
      uint32_t             PageNum;    /* Page number */
      uint32_t             PageCount;  /* Page count */
    } WritePages;
    struct {                           /* EraseBlocks command params */
      uint32_t             BlockNum;   /* Block number */
      uint32_t             BlockCount; /* Block count */
    } EraseBlocks;
    struct {                           /* WriteRawPage command params */
      uint8_t             *DstPtr;     /* Buffer for data */
      uint32_t             PageNum;    /* Page number */
      uint32_t             ColumnAddress; /* Column address */
      uint32_t             Size;       /* Data size */
    } ReadRawPage;
    struct {                           /* WriteRawPage command params */
      uint8_t             *SrcPtr;     /* Buffer with data */
      uint32_t             PageNum;    /* Page number */
      uint32_t             ColumnAddress; /* Column address */
      uint32_t             Size;       /* Data size */
    } WriteRawPage;
  } CmdParam;
  LDD_TError               CmdStatus;  /* Command status */
  uint32_t                 ErrorParam; /* OnCmdError event parameter */
} LDD_NFC_TCmd;

typedef struct NFC1_TDeviceData_Struct {
  NFC1_TEccStatus             EccStatus[S34ML02G100BHI000_PAGE_READ_BATCH_SIZE]; /* Place for ECC status */
  LDD_NFC_TCmd                Cmd;     /* Command */
  uint32_t                    CfgRegVal; /* CFG register value */
  bool                        ISR;     /* TRUE if ISR is in progress */
  LDD_TUserData              *UserDataPtr; /* User device data structure */
} NFC1_TDeviceData, *NFC1_TDeviceDataPtr;

/* {Default RTOS Adapter} Static object used for simulation of dynamic driver memory allocation */
static NFC1_TDeviceData DevDataPtr__DEFAULT_RTOS_ALLOC __attribute__ ((aligned (8)));
/* {Default RTOS Adapter} Global variable used for passing a parameter into ISR */
static NFC1_TDeviceDataPtr INT_NFC__DEFAULT_RTOS_ISRPARAM;
static LDD_TError NFC1_StartCommand(LDD_TDeviceData *DeviceDataPtr, LDD_NFC_TCmd *CommandPtr);

/*
** ===================================================================
**     Method      :  NFC1_Lock (component NFC_LDD)
**
**     Description :
**         Module lock
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
static void NFC1_Lock(NFC1_TDeviceData *DevDataPtr)
{
  if (!DevDataPtr->ISR) {
    /* {Default RTOS Adapter} Critical section begin, general PE function is used */
    EnterCritical();
  }
}

/*
** ===================================================================
**     Method      :  NFC1_Unlock (component NFC_LDD)
**
**     Description :
**         Module unlock
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
static void NFC1_Unlock(NFC1_TDeviceData *DevDataPtr)
{
  if (!DevDataPtr->ISR) {
    /* {Default RTOS Adapter} Critical section end, general PE function is used */
    ExitCritical();
  }
}

/*
** ===================================================================
**     Method      :  NFC1_Init (component NFC_LDD)
*/
/*!
**     @brief
**         Initializes the device. Allocates memory for the device data
**         structure, allocates interrupt vectors and sets interrupt
**         priority, sets pin routing, sets timing, etc. If the "Enable
**         in init. code" property is set to "yes" ([Enabled in init.
**         code]) value then the device is also enabled(see the
**         description of the Enable() method). In this case the
**         Enable() method is not necessary and needn't to be generated.
**         This method can be called only once. Before the second call
**         of Init() the Deinit() must be called first.
**     @param
**         UserDataPtr     - Pointer to the user or
**                           RTOS specific data. This pointer will be
**                           passed as an event or callback parameter.
**     @return
**                         - Device data structure pointer.
*/
/* ===================================================================*/
LDD_TDeviceData* NFC1_Init(LDD_TUserData *UserDataPtr)
{
  NFC1_TDeviceData           *DevDataPtr;

  /* Allocate HAL device structure */
  /* {Default RTOS Adapter} Driver memory allocation: Dynamic allocation is simulated by a pointer to the static object */
  DevDataPtr = &DevDataPtr__DEFAULT_RTOS_ALLOC;
  /* {Default RTOS Adapter} Driver memory allocation: Fill the allocated memory by zero value */
  PE_FillMemory(DevDataPtr, 0U, sizeof(NFC1_TDeviceData));
  DevDataPtr->UserDataPtr = UserDataPtr; /* Store the RTOS device structure */
  /* Interrupt vector(s) allocation */
  /* {Default RTOS Adapter} Set interrupt vector: IVT is static, ISR parameter is passed by the global variable */
  INT_NFC__DEFAULT_RTOS_ISRPARAM =  DevDataPtr;
  /* Interrupt vector(s) priority setting */
  /* NVICIP95: PRI95=0x80 */
  NVICIP95 = NVIC_IP_PRI95(0x80);
  /* NVICISER2: SETENA|=0x80000000 */
  NVICISER2 |= NVIC_ISER_SETENA(0x80000000);
  /* Pin routing */
  /* PORTC_PCR17: ISF=0,MUX=6 */
  PORTC_PCR17 = (uint32_t)((PORTC_PCR17 & (uint32_t)~(uint32_t)(
                 PORT_PCR_ISF_MASK |
                 PORT_PCR_MUX(0x01)
                )) | (uint32_t)(
                 PORT_PCR_MUX(0x06)
                ));/* PTC17/CAN1_TX/UART3_TX/ENET0_1588_TMR1/FBa_CS4_b/FBa_TSIZ0/FBa_BE31_24_BLS7_0_b/NFC_CE0_b */
  /* PORTC_PCR16: ISF=0,MUX=6 */
  PORTC_PCR16 = (uint32_t)((PORTC_PCR16 & (uint32_t)~(uint32_t)(
                 PORT_PCR_ISF_MASK |
                 PORT_PCR_MUX(0x01)
                )) | (uint32_t)(
                 PORT_PCR_MUX(0x06)
                ));/* PTC16/CAN1_RX/UART3_RX/ENET0_1588_TMR0/FBa_CS5_b/FBa_TSIZ1/FBa_BE23_16_BLS15_8_b/NFC_RB */
  /* PORTC_PCR17: ISF=0,MUX=6 */
  PORTC_PCR17 = (uint32_t)((PORTC_PCR17 & (uint32_t)~(uint32_t)(
                 PORT_PCR_ISF_MASK |
                 PORT_PCR_MUX(0x01)
                )) | (uint32_t)(
                 PORT_PCR_MUX(0x06)
                ));/* PTC17/CAN1_TX/UART3_TX/ENET0_1588_TMR1/FBa_CS4_b/FBa_TSIZ0/FBa_BE31_24_BLS7_0_b/NFC_CE0_b */
  /* PORTC_PCR16: ISF=0,MUX=6 */
  PORTC_PCR16 = (uint32_t)((PORTC_PCR16 & (uint32_t)~(uint32_t)(
                 PORT_PCR_ISF_MASK |
                 PORT_PCR_MUX(0x01)
                )) | (uint32_t)(
                 PORT_PCR_MUX(0x06)
                ));/* PTC16/CAN1_RX/UART3_RX/ENET0_1588_TMR0/FBa_CS5_b/FBa_TSIZ1/FBa_BE23_16_BLS15_8_b/NFC_RB */
  /* PORTD_PCR9: ISF=0,MUX=6 */
  PORTD_PCR9 = (uint32_t)((PORTD_PCR9 & (uint32_t)~(uint32_t)(
                PORT_PCR_ISF_MASK |
                PORT_PCR_MUX(0x01)
               )) | (uint32_t)(
                PORT_PCR_MUX(0x06)
               ));/* PTD9/I2C0_SDA/UART5_TX/FBa_A17/NFC_ALE */
  /* PORTD_PCR8: ISF=0,MUX=6 */
  PORTD_PCR8 = (uint32_t)((PORTD_PCR8 & (uint32_t)~(uint32_t)(
                PORT_PCR_ISF_MASK |
                PORT_PCR_MUX(0x01)
               )) | (uint32_t)(
                PORT_PCR_MUX(0x06)
               ));/* PTD8/I2C0_SCL/UART5_RX/FBa_A16/NFC_CLE */
  /* PORTD_PCR10: ISF=0,MUX=6 */
  PORTD_PCR10 = (uint32_t)((PORTD_PCR10 & (uint32_t)~(uint32_t)(
                 PORT_PCR_ISF_MASK |
                 PORT_PCR_MUX(0x01)
                )) | (uint32_t)(
                 PORT_PCR_MUX(0x06)
                ));/* PTD10/UART5_RTS_b/FBa_A18/NFC_RE */
  /* PORTC_PCR11: ISF=0,MUX=5 */
  PORTC_PCR11 = (uint32_t)((PORTC_PCR11 & (uint32_t)~(uint32_t)(
                 PORT_PCR_ISF_MASK |
                 PORT_PCR_MUX(0x02)
                )) | (uint32_t)(
                 PORT_PCR_MUX(0x05)
                ));/* ADC1_SE7b/PTC11/LLWU_P11/I2C1_SDA/FTM3_CH7/I2S0_RXD1/FBa_RW_b/NFC_WE */
  /* PORTD_PCR5: ISF=0,MUX=5 */
  PORTD_PCR5 = (uint32_t)((PORTD_PCR5 & (uint32_t)~(uint32_t)(
                PORT_PCR_ISF_MASK |
                PORT_PCR_MUX(0x02)
               )) | (uint32_t)(
                PORT_PCR_MUX(0x05)
               ));/* ADC0_SE6b/PTD5/SPI0_PCS2/UART0_CTS_b/UART0_COL_b/FTM0_CH5/FBa_AD1/NFC_DATA0/EWM_OUT_b */
  /* PORTD_PCR4: ISF=0,MUX=5 */
  PORTD_PCR4 = (uint32_t)((PORTD_PCR4 & (uint32_t)~(uint32_t)(
                PORT_PCR_ISF_MASK |
                PORT_PCR_MUX(0x02)
               )) | (uint32_t)(
                PORT_PCR_MUX(0x05)
               ));/* PTD4/LLWU_P14/SPI0_PCS1/UART0_RTS_b/FTM0_CH4/FBa_AD2/NFC_DATA1/EWM_IN */
  /* PORTC_PCR10: ISF=0,MUX=5 */
  PORTC_PCR10 = (uint32_t)((PORTC_PCR10 & (uint32_t)~(uint32_t)(
                 PORT_PCR_ISF_MASK |
                 PORT_PCR_MUX(0x02)
                )) | (uint32_t)(
                 PORT_PCR_MUX(0x05)
                ));/* ADC1_SE6b/PTC10/I2C1_SCL/FTM3_CH6/I2S0_RX_FS/FBa_AD5/NFC_DATA2/I2S1_MCLK */
  /* PORTC_PCR9: ISF=0,MUX=5 */
  PORTC_PCR9 = (uint32_t)((PORTC_PCR9 & (uint32_t)~(uint32_t)(
                PORT_PCR_ISF_MASK |
                PORT_PCR_MUX(0x02)
               )) | (uint32_t)(
                PORT_PCR_MUX(0x05)
               ));/* ADC1_SE5b/CMP0_IN3/PTC9/FTM3_CH5/I2S0_RX_BCLK/FBa_AD6/NFC_DATA3/FTM2_FLT0 */
  /* PORTC_PCR8: ISF=0,MUX=5 */
  PORTC_PCR8 = (uint32_t)((PORTC_PCR8 & (uint32_t)~(uint32_t)(
                PORT_PCR_ISF_MASK |
                PORT_PCR_MUX(0x02)
               )) | (uint32_t)(
                PORT_PCR_MUX(0x05)
               ));/* ADC1_SE4b/CMP0_IN2/PTC8/FTM3_CH4/I2S0_MCLK/FBa_AD7/NFC_DATA4 */
  /* PORTC_PCR7: ISF=0,MUX=5 */
  PORTC_PCR7 = (uint32_t)((PORTC_PCR7 & (uint32_t)~(uint32_t)(
                PORT_PCR_ISF_MASK |
                PORT_PCR_MUX(0x02)
               )) | (uint32_t)(
                PORT_PCR_MUX(0x05)
               ));/* CMP0_IN1/PTC7/SPI0_SIN/USB_SOF_OUT/I2S0_RX_FS/FBa_AD8/NFC_DATA5 */
  /* PORTC_PCR6: ISF=0,MUX=5 */
  PORTC_PCR6 = (uint32_t)((PORTC_PCR6 & (uint32_t)~(uint32_t)(
                PORT_PCR_ISF_MASK |
                PORT_PCR_MUX(0x02)
               )) | (uint32_t)(
                PORT_PCR_MUX(0x05)
               ));/* CMP0_IN0/PTC6/LLWU_P10/SPI0_SOUT/PDB0_EXTRG/I2S0_RX_BCLK/FBa_AD9/NFC_DATA6/I2S0_MCLK */
  /* PORTC_PCR5: ISF=0,MUX=5 */
  PORTC_PCR5 = (uint32_t)((PORTC_PCR5 & (uint32_t)~(uint32_t)(
                PORT_PCR_ISF_MASK |
                PORT_PCR_MUX(0x02)
               )) | (uint32_t)(
                PORT_PCR_MUX(0x05)
               ));/* PTC5/LLWU_P9/SPI0_SCK/LPTMR0_ALT2/I2S0_RXD0/FBa_AD10/NFC_DATA7/CMP0_OUT/I2S1_TX_FS */
  /* Set clock source */
  /* SIM_SOPT2: NFCSRC=2,NFC_CLKSEL=0 */
  SIM_SOPT2 = (uint32_t)((SIM_SOPT2 & (uint32_t)~(uint32_t)(
               SIM_SOPT2_NFCSRC(0x01) |
               SIM_SOPT2_NFC_CLKSEL_MASK
              )) | (uint32_t)(
               SIM_SOPT2_NFCSRC(0x02)
              ));                      /* Clock source=Divided Pll1 clock */
  /* Set multiplier and divider */
  /* SIM_CLKDIV4: NFCDIV=0x0C,NFCFRAC=0 */
  SIM_CLKDIV4 = (uint32_t)((SIM_CLKDIV4 & (uint32_t)~(uint32_t)(
                 SIM_CLKDIV4_NFCDIV(0x13) |
                 SIM_CLKDIV4_NFCFRAC(0x07)
                )) | (uint32_t)(
                 SIM_CLKDIV4_NFCDIV(0x0C)
                ));                    /* Div=13 - Mult=1  */
  /* Enable module clock */
  /* SIM_SCGC3: NFC=1 */
  SIM_SCGC3 |= SIM_SCGC3_NFC_MASK;
  NFC_DMA2 = (uint32_t)DevDataPtr;
  /* NFC_DMACFG: COUNT1=0,COUNT2=1,OFFSET2=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,ACT1=0,ACT2=1 */
  NFC_DMACFG = NFC_DMACFG_COUNT1(0x00) |
               NFC_DMACFG_COUNT2(0x01) |
               NFC_DMACFG_OFFSET2(0x00) |
               NFC_DMACFG_ACT2_MASK;
  /* NFC_CFG: STOPWERR=1,ECCAD=0x0100,ECCSRAM=1,DMAREQ=1,ECCMODE=7,FAST=0,IDCNT=0,TIMEOUT=5,BITWIDTH=0,??=0,AIAD=1,AIBN=1,PAGECNT=1 */
  NFC_CFG = NFC_CFG_STOPWERR_MASK |
            NFC_CFG_ECCAD(0x0100) |
            NFC_CFG_ECCSRAM_MASK |
            NFC_CFG_DMAREQ_MASK |
            NFC_CFG_ECCMODE(0x07) |
            NFC_CFG_IDCNT(0x00) |
            NFC_CFG_TIMEOUT(0x05) |
            NFC_CFG_AIAD_MASK |
            NFC_CFG_AIBN_MASK |
            NFC_CFG_PAGECNT(0x01);
  DevDataPtr->CfgRegVal = 0xC03E0531U;
  /* NFC_RAR: ??=0,??=0,CS1=0,CS0=1,??=0,??=0,RB1=0,RB0=1,BYTE3=0,BYTE2=0,BYTE1=0 */
  NFC_RAR = NFC_RAR_CS0_MASK |
            NFC_RAR_RB0_MASK |
            NFC_RAR_BYTE3(0x00) |
            NFC_RAR_BYTE2(0x00) |
            NFC_RAR_BYTE1(0x00);
  /* NFC_RAI: ??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,INC3=0,INC2=0,INC1=1 */
  NFC_RAI = (NFC_RAI_INC3(0x00) | NFC_RAI_INC2(0x00) | NFC_RAI_INC1(0x01));
  /* NFC_ISR: WERR=0,DONE=0,IDLE=0,??=0,WERRNS=0,CMDBUSY=0,RESBUSY=0,ECCBUSY=0,DMABUSY=0,WERREN=0,DONEEN=0,IDLEEN=0,WERRCLR=0,DONECLR=1,IDLECLR=1,??=1,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,RESBN=0,ECCBN=0,DMABN=0 */
  NFC_ISR = NFC_ISR_DONECLR_MASK |
            NFC_ISR_IDLECLR_MASK |
            NFC_ISR_RESBN(0x00) |
            NFC_ISR_ECCBN(0x00) |
            NFC_ISR_DMABN(0x00) |
            0x00010000U;
  /* Registration of the device structure */
  PE_LDD_RegisterDeviceStructure(PE_LDD_COMPONENT_NFC1_ID,DevDataPtr);
  return (LDD_TDeviceData*)(DevDataPtr);                    /* Return pointer to the data data structure */
}

/*
** ===================================================================
**     Method      :  NFC1_Reset (component NFC_LDD)
*/
/*!
**     @brief
**         Starts the "Reset" operation. The method doesn't wait for
**         the end of the operation. The [OnCmdDone()] event is called
**         as soon as the operation is done. The operation may be
**         executed with the target in any state. All pending
**         operations of the target are cancelled. The method puts the
**         target in its default power-up state. As part of the reset
**         command, all LUNs are also reset.
**     @param
**         DeviceDataPtr   - Device data structure
**                           pointer returned by [Init] method.
**     @param
**         TargetId        - Target identifier. If the only
**                           one target is defined (see [Target list]
**                           property) the, parameter is not used.
**     @return
**                         - Error code, possible codes:
**                           ERR_DISABLED - Device is disabled.
**                           ERR_SPEED - The component does not work in
**                           the active speed mode.
**                           ERR_PARAM_CHIP_SELECT - Unknown target.
**                           ERR_BUSY - Target is busy (other command is
**                           pending).
**                           ERR_OK - Command was accepted.
*/
/* ===================================================================*/
LDD_TError NFC1_Reset(LDD_TDeviceData *DeviceDataPtr, LDD_NFC_TTargetID TargetId)
{
  //NFC1_TDeviceData           *DevDataPtr = (NFC1_TDeviceData*)DeviceDataPtr;
  LDD_NFC_TCmd CmdPtr;

  (void)TargetId;                      /* Parameter is not used, suppress unused argument warning */
  CmdPtr.Cmd = LDD_NFC_CMD_RESET;
  return NFC1_StartCommand(DeviceDataPtr, &CmdPtr);
}

/*
** ===================================================================
**     Method      :  NFC1_ReadID (component NFC_LDD)
*/
/*!
**     @brief
**         Starts the "Read ID" operation. The method doesn't wait for
**         the end of the operation. The [OnCmdDone()] event is called
**         as soon as the operation is done. The method can be used to
**         determine the JEDEC manufacturer ID and the device ID for
**         the particular NAND part by specifying an address of 00h.
**         Reading beyond the first two bytes yields values as
**         specified by the manufacturer. The method can also be used
**         to identify that the target supports the ONFI specification.
**         If the target supports the ONFI specification, then the ONFI
**         signature shall be returned. The ONFI signature is the ASCII
**         encoding of =ONFI where =O = 4Fh, =N = 4Eh, =F = 46h, and =I
**         = 49h. Reading beyond four bytes yields indeterminate values.
**     @param
**         DeviceDataPtr   - Device data structure
**                           pointer returned by [Init] method.
**     @param
**         TargetId        - Target identifier. If the only
**                           one target is defined (see [Target list]
**                           property) the, parameter is not used.
**     @param
**         Address         - Address. For the "Read ID" command,
**                           only addresses of 0x00h and 20h are valid.
**                           To retrieve the ONFI signature an address
**                           of 0x20h shall be entered (i.e. it is not
**                           valid to enter an address of 0x00h and read
**                           36 bytes to get the ONFI signature).
**     @param
**         Size            - Requested data size
**     @param
**         DstPtr          - Pointer to data buffer .
**     @return
**                         - Error code, possible codes:
**                           ERR_DISABLED - Device is disabled.
**                           ERR_SPEED - The component does not work in
**                           the active speed mode.
**                           ERR_PARAM_CHIP_SELECT - Unknown target.
**                           ERR_BUSY - Target is busy (other command is
**                           pending).
**                           ERR_PARAM_SIZE - Size parameter value is
**                           out of range.
**                           ERR_OK - Command was accepted.
*/
/* ===================================================================*/
LDD_TError NFC1_ReadID(LDD_TDeviceData *DeviceDataPtr, LDD_NFC_TTargetID TargetId, uint32_t Address, uint32_t Size, uint8_t *DstPtr)
{
  //NFC1_TDeviceData           *DevDataPtr = (NFC1_TDeviceData*)DeviceDataPtr;
  LDD_NFC_TCmd CmdPtr;

  (void)TargetId;                      /* Parameter is not used, suppress unused argument warning */
  /* Input parameter test - this test can be disabled by setting the "Ignore range checking"
     property to the "yes" value in the "Configuration inspector" */
  if (Size > 0x05U) {
    return ERR_PARAM_SIZE;
  }
  CmdPtr.Cmd = LDD_NFC_CMD_READ_ID;
  CmdPtr.CmdParam.ReadID.Address = Address;
  CmdPtr.CmdParam.ReadID.Size = Size;
  CmdPtr.CmdParam.ReadID.DstPtr = DstPtr;
  return NFC1_StartCommand(DeviceDataPtr, &CmdPtr);
}

/*
** ===================================================================
**     Method      :  NFC1_ReadPages (component NFC_LDD)
*/
/*!
**     @brief
**         Starts the "Read page" operation of one or more pages. The
**         method doesn't wait for the end of the operation. The
**         [OnCmdDone()] event is always called as soon as the
**         operation is done (all pages are copied to the user provided
**         buffer). In case of error the [OnCmdError()] event is
**         invoked for each page containing unrecoverable ECC error if
**         ECC is enabled.
**     @param
**         DeviceDataPtr   - Device data structure
**                           pointer returned by [Init] method.
**     @param
**         TargetId        - Target id. If the only one
**                           target is defined (see [Target list]
**                           property) this parameter is not used.
**     @param
**         PageNumber      - Page number.
**     @param
**         PageCount       - Page count to read.
**     @param
**         DstPtr          - Pointer to data buffer .Pointer to
**                           data buffer . [Note:] On Kinetis and Vybrid
**                           MCUs internal DMA engine requires source
**                           buffer to be 8 bytes aligned and page user
**                           data size to be multiple of 8.
**     @return
**                         - Error code, possible codes:
**                           ERR_DISABLED - Device is disabled.
**                           ERR_SPEED - The component does not work in
**                           the active speed mode.
**                           ERR_PARAM_CHIP_SELECT - Unknown target.
**                           ERR_BUSY - Target is busy (other command is
**                           pending).
**                           ERR_PARAM_RANGE - Page number parameter
**                           value is out of range.
**                           ERR_PARAM_LENGTH - Sum of Page number and
**                           Page count parameter values is out of range.
**                           ERR_PARAM_ADDRESS - Destination buffer
**                           address is not correctly aligned.
**                           ERR_OK - Command was accepted.
*/
/* ===================================================================*/
LDD_TError NFC1_ReadPages(LDD_TDeviceData *DeviceDataPtr, LDD_NFC_TTargetID TargetId, uint32_t PageNumber, uint32_t PageCount, uint8_t *DstPtr)
{
  //NFC1_TDeviceData           *DevDataPtr = (NFC1_TDeviceData*)DeviceDataPtr;
  LDD_NFC_TCmd CmdPtr;

  (void)TargetId;                      /* Parameter is not used, suppress unused argument warning */
  /* Input parameter test - this test can be disabled by setting the "Ignore range checking"
     property to the "yes" value in the "Configuration inspector" */
  if (PageNumber >= S34ML02G100BHI000_PAGE_COUNT) {
    return ERR_PARAM_RANGE;
  }
  /* Input parameter test - this test can be disabled by setting the "Ignore range checking"
     property to the "yes" value in the "Configuration inspector" */
  if ((PageNumber + PageCount) > S34ML02G100BHI000_PAGE_COUNT) {
    return ERR_PARAM_LENGTH;
  }
  /* Input parameter test - this test can be disabled by setting the "Ignore range checking"
     property to the "yes" value in the "Configuration inspector" */
  if ((((uint32_t)DstPtr & 0x07U) != 0) | (DstPtr == NULL)) {
    return ERR_PARAM_ADDRESS;
  }
  CmdPtr.Cmd = LDD_NFC_CMD_READ_PAGES;
  CmdPtr.CmdParam.ReadPages.PageNum = PageNumber;
  CmdPtr.CmdParam.ReadPages.PageCount = PageCount;
  CmdPtr.CmdParam.ReadPages.DstPtr = DstPtr;
  return NFC1_StartCommand(DeviceDataPtr, &CmdPtr);
}

/*
** ===================================================================
**     Method      :  NFC1_WritePages (component NFC_LDD)
*/
/*!
**     @brief
**         Starts the "Write page" operation of one or more pages. The
**         method doesn't wait for the end of the operation. The
**         [OnCmdDone()] event is always called as soon as the
**         operation is done (all pages are copied to the user provided
**         buffer). In case of error the [OnCmdError()] event is
**         invoked for each page not possible to write correctly.
**     @param
**         DeviceDataPtr   - Device data structure
**                           pointer returned by [Init] method.
**     @param
**         TargetId        - Target id. If the only one
**                           target is defined (see [Target list]
**                           property) this parameter is not used.
**     @param
**         PageNumber      - Page number.
**     @param
**         PageCount       - Page count to read.
**     @param
**         SrcPtr          - Pointer to data buffer . [Note:] On
**                           Kinetis and Vybrid MCUs internal DMA engine
**                           requires destination buffer to be 8 bytes
**                           aligned and page user data size to be
**                           multiple of 8 .
**     @return
**                         - Error code, possible codes:
**                           ERR_DISABLED - Device is disabled.
**                           ERR_SPEED - The component does not work in
**                           the active speed mode.
**                           ERR_PARAM_CHIP_SELECT - Unknown target.
**                           ERR_BUSY - Target is busy (other command is
**                           pending).
**                           ERR_PARAM_RANGE - Page number parameter
**                           value is out of range.
**                           ERR_PARAM_LENGTH - Sum of Page number and
**                           Page count parameter values is out of range.
**                           ERR_PARAM_ADDRESS - Source buffer address
**                           is not correctly aligned.
**                           ERR_OK - Command was accepted.
*/
/* ===================================================================*/
LDD_TError NFC1_WritePages(LDD_TDeviceData *DeviceDataPtr, LDD_NFC_TTargetID TargetId, uint32_t PageNumber, uint32_t PageCount, uint8_t *SrcPtr)
{
  //NFC1_TDeviceData           *DevDataPtr = (NFC1_TDeviceData*)DeviceDataPtr;
  LDD_NFC_TCmd CmdPtr;

  (void)TargetId;                      /* Parameter is not used, suppress unused argument warning */
  /* Input parameter test - this test can be disabled by setting the "Ignore range checking"
     property to the "yes" value in the "Configuration inspector" */
  if (PageNumber >= S34ML02G100BHI000_PAGE_COUNT) {
    return ERR_PARAM_RANGE;
  }
  /* Input parameter test - this test can be disabled by setting the "Ignore range checking"
     property to the "yes" value in the "Configuration inspector" */
  if ((PageNumber + PageCount) > S34ML02G100BHI000_PAGE_COUNT) {
    return ERR_PARAM_LENGTH;
  }
  /* Input parameter test - this test can be disabled by setting the "Ignore range checking"
     property to the "yes" value in the "Configuration inspector" */
  if ((((uint32_t)SrcPtr & 0x07U) != 0) | (SrcPtr == NULL)) {
    return ERR_PARAM_ADDRESS;
  }
  CmdPtr.Cmd = LDD_NFC_CMD_WRITE_PAGES;
  CmdPtr.CmdParam.WritePages.PageNum = PageNumber;
  CmdPtr.CmdParam.WritePages.PageCount = PageCount;
  CmdPtr.CmdParam.WritePages.SrcPtr = SrcPtr;
  return NFC1_StartCommand(DeviceDataPtr, &CmdPtr);
}

/*
** ===================================================================
**     Method      :  NFC1_EraseBlocks (component NFC_LDD)
*/
/*!
**     @brief
**         Starts the "Erase" operation of one or more block. The
**         method doesn't wait for the end of the operation. The
**         [OnCmdDone()] event is always called as soon as the
**         operation is done (all pages are copied to the user provided
**         buffer). In case of error the [OnCmdError()] event is
**         invoked for each block not possible to erase correctly.
**     @param
**         DeviceDataPtr   - Device data structure
**                           pointer returned by [Init] method.
**     @param
**         TargetId        - Target id. If the only one
**                           target is defined (see [Target list]
**                           property) this parameter is not used.
**     @param
**         BlockNumber     - Block number. The block
**                           number(address) can be obtain from page
**                           address according to the formula: Block
**                           address = Page address /
**                           "Target_ID"_BLOCK_PAGE_COUNT where Target
**                           ID is value of "Target ID" property.
**     @param
**         BlockCount      - Block count
**     @return
**                         - Error code, possible codes:
**                           ERR_DISABLED - Device is disabled.
**                           ERR_SPEED - The component does not work in
**                           the active speed mode.
**                           ERR_PARAM_CHIP_SELECT - Unknown target.
**                           ERR_BUSY - Target is busy (other command is
**                           pending).
**                           ERR_PARAM_RANGE - Block number parameter
**                           value is out of range.
**                           ERR_PARAM_LENGTH - Sum of Block number and
**                           Block count parameter values is out of
**                           range.
**                           ERR_OK - Command was accepted.
*/
/* ===================================================================*/
LDD_TError NFC1_EraseBlocks(LDD_TDeviceData *DeviceDataPtr, LDD_NFC_TTargetID TargetId, uint32_t BlockNumber, uint32_t BlockCount)
{
  //NFC1_TDeviceData           *DevDataPtr = (NFC1_TDeviceData*)DeviceDataPtr;
  LDD_NFC_TCmd CmdPtr;

  (void)TargetId;                      /* Parameter is not used, suppress unused argument warning */
  /* Input parameter test - this test can be disabled by setting the "Ignore range checking"
     property to the "yes" value in the "Configuration inspector" */
  if (BlockNumber >= S34ML02G100BHI000_BLOCK_COUNT) {
    return ERR_PARAM_RANGE;
  }
  /* Input parameter test - this test can be disabled by setting the "Ignore range checking"
     property to the "yes" value in the "Configuration inspector" */
  if ((BlockNumber + BlockCount) > S34ML02G100BHI000_BLOCK_COUNT) {
    return ERR_PARAM_LENGTH;
  }
  CmdPtr.Cmd = LDD_NFC_CMD_ERASE_BLOCKS;
  CmdPtr.CmdParam.EraseBlocks.BlockNum = BlockNumber;
  CmdPtr.CmdParam.EraseBlocks.BlockCount = BlockCount;
  return NFC1_StartCommand(DeviceDataPtr, &CmdPtr);
}

/*
** ===================================================================
**     Method      :  NFC1_ReadRawPage (component NFC_LDD)
*/
/*!
**     @brief
**         Starts the "Read page" operation of one physical page or
**         part of physical page. ECC mode is disabled. Raw data are
**         read from the physical page. The method doesn't wait for the
**         end of the operation. The [OnCmdDone()] event is always
**         called as soon as the operation is done (data are copied to
**         the user provided buffer or error appears). In case of error
**         the [OnCmdError()] event is invoked before the OnCmdDone()
**         event . This method can be used to get Bad block marker or
**         additional information from the spare area size of the page.
**     @param
**         DeviceDataPtr   - Device data structure
**                           pointer returned by [Init] method.
**     @param
**         TargetId        - Target id. If the only one
**                           target is defined (see [Target list]
**                           property) this parameter is not used.
**     @param
**         PhyPageNumber   - Page number.
**     @param
**         ColumnAddress   - Column address.
**     @param
**         Size            - Number of bytes to read. [Note:] On
**                           Kinetis and Vybrid MCUs internal DMA engine
**                           requires data size to be multiple of 8.
**     @param
**         DstPtr          - Pointer to data buffer. [Note:] On
**                           Kinetis and Vybrid MCUs internal DMA engine
**                           requires buffer address to be 8 bytes
**                           aligned.
**     @return
**                         - Error code, possible codes:
**                           ERR_DISABLED - Device is disabled.
**                           ERR_SPEED - The component does not work in
**                           the active speed mode.
**                           ERR_PARAM_CHIP_SELECT - Unknown target.
**                           ERR_BUSY - Target is busy (other command is
**                           pending).
**                           ERR_PARAM_RANGE - Physical page number
**                           parameter value is out of range.
**                           ERR_PARAM_LENGTH - Sum of Column address
**                           and Size parameter values is out of range.
**                           ERR_PARAM_ADDRESS - Destination buffer
**                           address is not correctly aligned.
**                           ERR_OK - Command was accepted.
*/
/* ===================================================================*/
LDD_TError NFC1_ReadRawPage(LDD_TDeviceData *DeviceDataPtr, LDD_NFC_TTargetID TargetId, uint32_t PhyPageNumber, uint32_t ColumnAddress, uint32_t Size, uint8_t *DstPtr)
{
  //NFC1_TDeviceData           *DevDataPtr = (NFC1_TDeviceData*)DeviceDataPtr;
  LDD_NFC_TCmd CmdPtr;

  (void)TargetId;                      /* Parameter is not used, suppress unused argument warning */
  /* Input parameter test - this test can be disabled by setting the "Ignore range checking"
     property to the "yes" value in the "Configuration inspector" */
  if (PhyPageNumber >= S34ML02G100BHI000_PHY_TOTAL_PAGE_COUNT) {
    return ERR_PARAM_RANGE;
  }
  /* Input parameter test - this test can be disabled by setting the "Ignore range checking"
     property to the "yes" value in the "Configuration inspector" */
  if (Size % 8U) {
    return ERR_PARAM_SIZE;
  }
  /* Input parameter test - this test can be disabled by setting the "Ignore range checking"
     property to the "yes" value in the "Configuration inspector" */
  if ((ColumnAddress + Size) > S34ML02G100BHI000_PHY_PAGE_SIZE) {
    return ERR_PARAM_LENGTH;
  }
  /* Input parameter test - this test can be disabled by setting the "Ignore range checking"
     property to the "yes" value in the "Configuration inspector" */
  if ((((uint32_t)DstPtr & 0x07U) != 0) | (DstPtr == NULL)) {
    return ERR_PARAM_ADDRESS;
  }
  CmdPtr.Cmd = LDD_NFC_CMD_READ_RAW_PAGE;
  CmdPtr.CmdParam.ReadRawPage.DstPtr = DstPtr;
  CmdPtr.CmdParam.ReadRawPage.PageNum = PhyPageNumber;
  CmdPtr.CmdParam.ReadRawPage.ColumnAddress = ColumnAddress;
  CmdPtr.CmdParam.ReadRawPage.Size = Size;
  return NFC1_StartCommand(DeviceDataPtr, &CmdPtr);
}

/*
** ===================================================================
**     Method      :  NFC1_StartCommand (component NFC_LDD)
**
**     Description :
**         StartCommand
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
static LDD_TError NFC1_StartCommand(LDD_TDeviceData *DeviceDataPtr, LDD_NFC_TCmd *CommandPtr)
{
  NFC1_TDeviceData           *DevDataPtr = (NFC1_TDeviceData *)DeviceDataPtr;
  LDD_NFC_TCmd               *CmdPtr = &DevDataPtr->Cmd;

  NFC1_Lock(DevDataPtr);
  if (DevDataPtr->Cmd.Cmd != LDD_NFC_CMD_NONE) {
    NFC1_Unlock(DevDataPtr);
    return ERR_BUSY;
  }
  *CmdPtr = *CommandPtr;                                   /* Make local copy of the command */
  CmdPtr->CmdStatus = ERR_OK;                              /* Suppose no errors */
  CmdPtr->ErrorParam = 0U;                                 /* Reset error counter */
  switch (CmdPtr->Cmd) {
    case LDD_NFC_CMD_RESET:
      NFC_PDD_SetResetCmd(NFC_BASE_PTR);
      break;
    case LDD_NFC_CMD_READ_ID:
      NFC_PDD_SetReadIdCmd(NFC_BASE_PTR, CmdPtr->CmdParam.ReadID.Address, CmdPtr->CmdParam.ReadID.Size);
      break;
    case LDD_NFC_CMD_READ_PAGES:
      NFC_PDD_SetDma1AndDma2(NFC_BASE_PTR, CmdPtr->CmdParam.ReadPages.DstPtr, S34ML02G100BHI000_VIRTUAL_PAGE_USER_DATA_SIZE,(uint32_t)&DevDataPtr->EccStatus, 8U, 8U);
      if (CmdPtr->CmdParam.ReadPages.PageCount < S34ML02G100BHI000_PAGE_READ_BATCH_SIZE) {
        NFC_PDD_SetRepeatCount(NFC_BASE_PTR, CmdPtr->CmdParam.ReadPages.PageCount);
      } else {
        NFC_PDD_SetRepeatCount(NFC_BASE_PTR, S34ML02G100BHI000_PAGE_READ_BATCH_SIZE);
      }
      NFC_PDD_SetRowAddressInc(NFC_BASE_PTR, 1U);
      NFC_PDD_SetSectorSize(NFC_BASE_PTR, S34ML02G100BHI000_VIRTUAL_PAGE_SIZE);
      NFC_PDD_SetReadPageCmd(NFC_BASE_PTR, CmdPtr->CmdParam.ReadPages.PageNum, 0U, NFC1_SRAM_BUFFER_0_IDX);
      NFC_PDD_SetEccModeDmaAndVirtPageCount(NFC_BASE_PTR,NFC_PDD_ECC_32_ERR,NFC_PDD_DMA_YES,S34ML02G100BHI000_VIRTUAL_PAGE_COUNT);
      break;
    case LDD_NFC_CMD_WRITE_PAGES:
      NFC_PDD_SetDma1(NFC_BASE_PTR, CmdPtr->CmdParam.WritePages.SrcPtr, S34ML02G100BHI000_VIRTUAL_PAGE_USER_DATA_SIZE);
      NFC_PDD_SetRepeatCount(NFC_BASE_PTR, CmdPtr->CmdParam.WritePages.PageCount);
      NFC_PDD_SetRowAddressInc(NFC_BASE_PTR, 1U);
      NFC_PDD_SetSectorSize(NFC_BASE_PTR, S34ML02G100BHI000_VIRTUAL_PAGE_SIZE);
      NFC_PDD_SetWritePageCmd(NFC_BASE_PTR, CmdPtr->CmdParam.WritePages.PageNum, 0U, NFC1_SRAM_BUFFER_0_IDX);
      NFC_PDD_SetEccModeDmaAndVirtPageCount(NFC_BASE_PTR,NFC_PDD_ECC_32_ERR,NFC_PDD_DMA_NO,S34ML02G100BHI000_VIRTUAL_PAGE_COUNT);
      break;
    case LDD_NFC_CMD_ERASE_BLOCKS:
      NFC_PDD_SetRepeatCount(NFC_BASE_PTR, CmdPtr->CmdParam.EraseBlocks.BlockCount);
      NFC_PDD_SetRowAddressInc(NFC_BASE_PTR, (S34ML02G100BHI000_PHY_PAGE_ADDRESS_MASK + 1U));
      NFC_PDD_SetEraseBlockCmd(NFC_BASE_PTR, CmdPtr->CmdParam.EraseBlocks.BlockNum << S34ML02G100BHI000_PHY_BLOCK_ADDRESS_SHIFT);
      break;
    case LDD_NFC_CMD_READ_RAW_PAGE:
      NFC_PDD_SetDma1(NFC_BASE_PTR, CmdPtr->CmdParam.ReadRawPage.DstPtr, ((CmdPtr->CmdParam.ReadRawPage.Size + 7U) & 0xFFFFFFF8U));
      NFC_PDD_SetRepeatCount(NFC_BASE_PTR, 0U);
      NFC_PDD_SetSectorSize(NFC_BASE_PTR, CmdPtr->CmdParam.ReadRawPage.Size);
      NFC_PDD_SetEccModeDmaAndVirtPageCount(NFC_BASE_PTR,NFC_PDD_ECC_0_ERR,NFC_PDD_DMA_YES,1U);
      NFC_PDD_SetReadPageCmd(NFC_BASE_PTR, CmdPtr->CmdParam.ReadRawPage.PageNum, CmdPtr->CmdParam.ReadRawPage.ColumnAddress, NFC1_SRAM_BUFFER_0_IDX);
      break;
    default:
      CmdPtr->CmdStatus = ERR_PARAM_COMMAND;
      break;
  }
  if (CmdPtr->CmdStatus == ERR_OK) {                       /* Command ready? */
    NFC_PDD_ClrInterruptFlags(NFC_BASE_PTR, NFC_PDD_WERR_INT | NFC_PDD_IDLE_INT); /* Yes, clear interrupt flags, */
    NFC_PDD_EnableInterrupt(NFC_BASE_PTR, NFC_PDD_WERR_INT | NFC_PDD_IDLE_INT); /* enable interrupts */
    NFC_PDD_StartCommand(NFC_BASE_PTR);                    /* and start command */
  }
  NFC1_Unlock(DevDataPtr);
  return CmdPtr->CmdStatus;
}


/*
** ===================================================================
**     Method      :  NFC1_Interrupt (component NFC_LDD)
**
**     Description :
**         NFC interrupt handler
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
PE_ISR(NFC1_Interrupt)
{
  /* {Default RTOS Adapter} ISR parameter is passed through the global variable */
  NFC1_TDeviceDataPtr DevDataPtr = INT_NFC__DEFAULT_RTOS_ISRPARAM;
  uint32_t       IntFlags = NFC_PDD_GetInterruptFlags(NFC_BASE_PTR);
  LDD_NFC_TCmd  *CmdPtr = &DevDataPtr->Cmd;
  uint32_t       x;
  LDD_NFC_TeCmd  CmdCode;
  
  NFC_PDD_ClrInterruptFlags(NFC_BASE_PTR, NFC_PDD_WERR_INT | NFC_PDD_IDLE_INT); /* Clear interrupt flags, */
  DevDataPtr->ISR = TRUE;
  CmdCode = CmdPtr->Cmd;                                   /* Remember command code */
  CmdPtr->Cmd = LDD_NFC_CMD_NONE;                          /* Suppose command is done */
  switch (CmdCode) {
    case LDD_NFC_CMD_NONE:
      break;
    case LDD_NFC_CMD_RESET:
      break;
    case LDD_NFC_CMD_READ_ID:
      for (x = 0U; x < CmdPtr->CmdParam.ReadID.Size; x++) {
        if (x == 0x04U) {
          CmdPtr->CmdParam.ReadID.DstPtr[x] = ((uint8_t *)(void *)(&NFC_SR2))[3];
        } else {
          CmdPtr->CmdParam.ReadID.DstPtr[x] = ((uint8_t *)(void *)(&NFC_SR1))[3U-x];
        }
      }
      break;
    case LDD_NFC_CMD_READ_PAGES:
      for (x=0U; ((x<S34ML02G100BHI000_PAGE_READ_BATCH_SIZE) && (CmdPtr->CmdParam.ReadPages.PageCount != 0U)); x++) { /* For each page check page status */
        if ((DevDataPtr->EccStatus[x]).Status & (uint8_t)0x80U) { /* Uncorrectable page? */
          NFC1_OnCmdError(DevDataPtr->UserDataPtr, 0U, CmdCode, CmdPtr->CmdParam.ReadPages.PageNum);
          CmdPtr->CmdStatus = ERR_FAILED;                  /* Remember status */
          CmdPtr->ErrorParam++;                            /* Increment error counter */
        }
        CmdPtr->CmdParam.ReadPages.PageCount--;
        CmdPtr->CmdParam.ReadPages.PageNum++;
      }
      if (CmdPtr->CmdParam.ReadPages.PageCount != 0U) {    /* Pages remaining? */
        if (CmdPtr->CmdParam.ReadPages.PageCount < S34ML02G100BHI000_PAGE_READ_BATCH_SIZE) {
          NFC_PDD_SetRepeatCount(NFC_BASE_PTR, CmdPtr->CmdParam.ReadPages.PageCount);
        } else {
          NFC_PDD_SetRepeatCount(NFC_BASE_PTR, S34ML02G100BHI000_PAGE_READ_BATCH_SIZE);
        }
        NFC_PDD_IncRowAddress(NFC_BASE_PTR, 1U);
        NFC_PDD_SetDma2Address(NFC_BASE_PTR, (uint32_t)&DevDataPtr->EccStatus);
        CmdPtr->Cmd = CmdCode;                             /* Read next page(s) */
      }
      break;
    case LDD_NFC_CMD_WRITE_PAGES:
      if (IntFlags & NFC_PDD_WERR_INT) {                   /* Error during page write? */
        CmdPtr->CmdStatus = ERR_FAILED;                    /* Remember status */
        NFC1_OnCmdError(DevDataPtr->UserDataPtr, 0U, CmdCode, (CmdPtr->CmdParam.WritePages.PageNum + (CmdPtr->CmdParam.WritePages.PageCount - NFC_PDD_GetRepeatCount(NFC_BASE_PTR))));
      }
      if (NFC_PDD_GetRepeatCount(NFC_BASE_PTR) != 0U) {
        CmdPtr->Cmd = CmdCode;                             /* Write next page(s) */
      }
      break;
    case LDD_NFC_CMD_ERASE_BLOCKS:
      if (IntFlags & NFC_PDD_WERR_INT) {                   /* Error during block erase? */
        CmdPtr->CmdStatus = ERR_FAILED;                    /* Remember status */
        NFC1_OnCmdError(DevDataPtr->UserDataPtr, 0U, CmdCode, (CmdPtr->CmdParam.EraseBlocks.BlockNum + (CmdPtr->CmdParam.EraseBlocks.BlockCount - NFC_PDD_GetRepeatCount(NFC_BASE_PTR))));
      }
      break;
    case LDD_NFC_CMD_READ_RAW_PAGE:
      break;
    default:
      break;
  }
  
  if (CmdPtr->Cmd == LDD_NFC_CMD_NONE ) {                  /* Command done? */
    NFC_PDD_DisableInterrupt(NFC_BASE_PTR, NFC_PDD_WERR_INT | NFC_PDD_IDLE_INT); /* Yes, disable interrupts */
    NFC1_OnCmdDone(DevDataPtr->UserDataPtr, 0U, CmdCode, CmdPtr->CmdStatus);
  } else {
    NFC_PDD_StartCommand(NFC_BASE_PTR);                    /* No, restart command */
  }
  DevDataPtr->ISR = FALSE;
}

/* END NFC1. */

#ifdef __cplusplus
}  /* extern "C" */
#endif

/*!
** @}
*/
/*
** ###################################################################
**
**     This file was created by Processor Expert 10.3 [05.09]
**     for the Freescale Kinetis series of microcontrollers.
**
** ###################################################################
*/
